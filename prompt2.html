<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>WebAudio Synth — FM Modulation</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 24px; max-width: 960px; }
    h1 { margin: 0 0 6px; }
    p { margin: 6px 0 14px; }
    .panel { display: grid; grid-template-columns: repeat(4, minmax(0,1fr)); gap: 12px; margin: 16px 0 20px; }
    fieldset { border: 1px solid #d0d0d0; border-radius: 12px; padding: 12px; }
    legend { padding: 0 6px; }
    label { display:block; font-size: 12px; opacity: .9; margin-top: 8px; }
    input[type=range]{ width:100%; }
    select, button { padding: 8px 10px; border-radius: 10px; border:1px solid #bbb; background:#f6f6f6; }
    button { cursor:pointer; }
    button:active { transform: translateY(1px); }
    .kbd{ display:inline-block; border:1px solid #ddd; padding:4px 6px; border-radius:6px; margin-right:6px; }
    .on{ background:#e8ffe8; border-color:#3a3; }
    .muted{ opacity:.65; }
    @media (max-width: 920px) { .panel { grid-template-columns: repeat(2, minmax(0,1fr)); } }
  </style>
</head>
<body>
  <h1>WebAudio Synth — FM Modulation</h1>
  <p>Touches (AZERTY) : <span class="kbd">A</span><span class="kbd">Z</span><span class="kbd">E</span><span class="kbd">R</span><span class="kbd">T</span><span class="kbd">Y</span><span class="kbd">U</span><span class="kbd">I</span><span class="kbd">O</span> — <span class="muted">A = Do4 (261.63 Hz)</span></p>

  <div class="panel">
    <fieldset>
      <legend>Audio</legend>
      <button id="init">Init Audio</button>
      <button id="panic">Panic (tout couper)</button>
      <label>Master Gain
        <input id="gain" type="range" min="0" max="1" step="0.01" value="0.4">
      </label>
    </fieldset>

    <fieldset>
      <legend>Carrier (son entendu)</legend>
      <label>Wave
        <select id="wave">
          <option>sine</option>
          <option selected>triangle</option>
          <option>square</option>
          <option>sawtooth</option>
        </select>
      </label>
      <label>Detune (cents)
        <input id="detune" type="range" min="-50" max="50" step="1" value="0">
      </label>
    </fieldset>

    <fieldset>
      <legend>Envelope (simple)</legend>
      <label>Attack (s)
        <input id="att" type="range" min="0" max="0.2" step="0.005" value="0.01">
      </label>
      <label>Release (s)
        <input id="rel" type="range" min="0" max="0.8" step="0.01" value="0.12">
      </label>
    </fieldset>

    <fieldset>
      <legend>FM (modulateur → fréquence)</legend>
      <label>Mod Wave
        <select id="modWave">
          <option selected>sine</option>
          <option>triangle</option>
          <option>square</option>
          <option>sawtooth</option>
        </select>
      </label>
      <label>Mod Freq (Hz)
        <input id="modFreq" type="range" min="0.1" max="400" step="0.1" value="5">
      </label>
      <label>FM Depth (Hz)
        <input id="fmDepth" type="range" min="0" max="600" step="1" value="25">
      </label>
      <p class="muted" style="font-size:12px;margin-top:8px">
        Astuce: <em>5–8 Hz</em> = vibrato/chorus ; <em>30–200 Hz</em> = timbres plus riches/« métalliques ».  
        La profondeur (Hz) est l’écart max autour de la note.
      </p>
    </fieldset>
  </div>

  <script>
    // === Globals ===
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    let ctx = null;
    let master = null;

    // Modulateur global (partagé par toutes les voix)
    let modOsc = null;
    let modGain = null;

    // Voix actives : key -> { osc, vca }
    const voices = new Map();

    // Mapping touches (AZERTY) -> fréquences
    const keyFreq = {
      'a': 261.63, // C4
      'z': 277.18, // C#4
      'e': 293.66, // D4
      'r': 311.13, // D#4
      't': 329.63, // E4
      'y': 349.23, // F4
      'u': 369.99, // F#4
      'i': 392.00, // G4
      'o': 415.30  // G#4
    };

    const now = () => ctx ? ctx.currentTime : 0;

    // === Init audio graph ===
    function initAudio() {
      if (ctx) return;
      ctx = new AudioContext();

      // Master
      master = ctx.createGain();
      master.gain.value = parseFloat(gain.value);
      master.connect(ctx.destination);

      // Modulateur FM global
      modOsc = ctx.createOscillator();
      modOsc.type = modWave.value;
      modOsc.frequency.value = parseFloat(modFreq.value);

      modGain = ctx.createGain();                // profondeur (Hz)
      modGain.gain.value = parseFloat(fmDepth.value);

      modOsc.connect(modGain);                   // La connexion vers les voix se fait à la création de voix
      modOsc.start();

      init.classList.add('on');
    }

    // === Création voix (carrier) ===
    function createVoice(freq) {
      const osc = ctx.createOscillator();
      osc.type = wave.value;
      osc.frequency.value = freq;
      osc.detune.value = parseFloat(detune.value);

      // VCA pour l’enveloppe
      const vca = ctx.createGain();
      vca.gain.value = 0;

      // Chaînage audio de la voix
      osc.connect(vca);
      vca.connect(master);

      // Enveloppe simple A/R
      const t = now();
      const A = parseFloat(att.value);
      vca.gain.cancelScheduledValues(t);
      vca.gain.setValueAtTime(0, t);
      vca.gain.linearRampToValueAtTime(1, t + A);

      // === FM : modGain → osc.frequency (en Hz) ===
      // On connecte le gain du modulateur au paramètre de fréquence de la porteuse
      modGain.connect(osc.frequency);

      osc.start();
      return { osc, vca };
    }

    // === Note On/Off ===
    function noteOn(key) {
      if (!ctx) initAudio();
      const freq = keyFreq[key.toLowerCase()];
      if (!freq || voices.has(key)) return;
      const voice = createVoice(freq);
      voices.set(key, voice);
    }

    function noteOff(key) {
      const v = voices.get(key);
      if (!v) return;

      const t = now();
      const R = parseFloat(rel.value);

      v.vca.gain.cancelScheduledValues(t);
      v.vca.gain.setValueAtTime(v.vca.gain.value, t);
      v.vca.gain.linearRampToValueAtTime(0, t + R);

      setTimeout(() => { try { v.osc.stop(); } catch(_){} }, (R*1000)+20);
      voices.delete(key);
    }

    // === Events clavier ===
    window.addEventListener('keydown', (e) => {
      if (e.repeat) return;
      if (ctx && ctx.state !== 'running') ctx.resume();
      noteOn(e.key);
    });

    window.addEventListener('keyup', (e) => noteOff(e.key));

    // === UI bindings ===
    init.onclick = () => {
      initAudio();
      if (ctx.state !== 'running') ctx.resume();
    };

    panic.onclick = () => {
      for (const k of [...voices.keys()]) noteOff(k);
    };

    gain.oninput = e => master && (master.gain.value = parseFloat(e.target.value));
    wave.oninput = () => {};    // pris à la création de la voix
    detune.oninput = () => {};

    modWave.oninput = e => modOsc && (modOsc.type = e.target.value);
    modFreq.oninput = e => modOsc && (modOsc.frequency.setValueAtTime(parseFloat(e.target.value), now()));
    fmDepth.oninput = e => modGain && (modGain.gain.setValueAtTime(parseFloat(e.target.value), now()));
  </script>
</body>
</html>
