<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Ultra Simple WebAudio Synth</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 24px; max-width: 860px; }
    h1 { margin: 0 0 4px; }
    p { margin: 6px 0 12px; }
    .panel { display: grid; grid-template-columns: repeat(4, minmax(0,1fr)); gap: 12px; margin: 16px 0 20px; }
    fieldset { border: 1px solid #d0d0d0; border-radius: 12px; padding: 12px; }
    legend { padding: 0 6px; }
    label { display:block; font-size: 12px; opacity: .85; margin-top: 8px; }
    input[type=range]{ width:100%; }
    button { padding: 8px 12px; border-radius: 10px; border:1px solid #bbb; background:#f6f6f6; cursor:pointer; }
    button:active { transform: translateY(1px); }
    .kbd{ display:inline-block; border:1px solid #ddd; padding:4px 6px; border-radius:6px; margin-right:6px; }
    .on{ background:#e8ffe8; border-color:#3a3; }
    .muted{ opacity:.6; }
  </style>
</head>
<body>
  <h1>Ultra Simple WebAudio Synth</h1>
  <p>Touches (AZERTY): <span class="kbd">A</span><span class="kbd">Z</span><span class="kbd">E</span><span class="kbd">R</span><span class="kbd">T</span><span class="kbd">Y</span><span class="kbd">U</span><span class="kbd">I</span><span class="kbd">O</span> — <span class="muted">A = Do4 (261.63 Hz)</span></p>

  <div class="panel">
    <fieldset>
      <legend>Audio</legend>
      <button id="init">Init Audio</button>
      <button id="panic">Panic (tout couper)</button>
    </fieldset>

    <fieldset>
      <legend>Oscillateur</legend>
      <label>Forme d'onde
        <select id="wave">
          <option>sine</option>
          <option selected>triangle</option>
          <option>square</option>
          <option>sawtooth</option>
        </select>
      </label>
      <label>Detune (cents)
        <input id="detune" type="range" min="-50" max="50" step="1" value="0">
      </label>
    </fieldset>

    <fieldset>
      <legend>Volume</legend>
      <label>Master Gain
        <input id="gain" type="range" min="0" max="1" step="0.01" value="0.4">
      </label>
    </fieldset>

    <fieldset>
      <legend>Enveloppe (simple)</legend>
      <label>Attack (s)
        <input id="att" type="range" min="0" max="0.2" step="0.005" value="0.01">
      </label>
      <label>Release (s)
        <input id="rel" type="range" min="0" max="0.8" step="0.01" value="0.1">
      </label>
    </fieldset>
  </div>

  <script>
    // === 1) Variables globales ===
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    let ctx = null;
    let master = null;     // Gain master
    const voices = new Map(); // key -> { osc, vca }

    // Mapping clavier (AZERTY) -> fréquences (chromatique à partir de Do4)
    const keyFreq = {
      'a': 261.63, // C4
      'z': 277.18, // C#4
      'e': 293.66, // D4
      'r': 311.13, // D#4
      't': 329.63, // E4
      'y': 349.23, // F4
      'u': 369.99, // F#4
      'i': 392.00, // G4
      'o': 415.30  // G#4
    };

    // Raccourci pour le temps courant audio
    const now = () => ctx ? ctx.currentTime : 0;

    // === 2) Initialisation du graphe audio ===
    function initAudio() {
      if (ctx) return;
      ctx = new AudioContext();
      master = ctx.createGain();
      master.gain.value = parseFloat(gain.value);
      master.connect(ctx.destination);
      init.classList.add('on');
    }

    // === 3) Création d'une voix (osc + vca) ===
    function createVoice(freq) {
      const osc = ctx.createOscillator();
      osc.type = wave.value;
      osc.frequency.value = freq;
      osc.detune.value = parseFloat(detune.value);

      // VCA (Gain par voix) pour faire l’attaque/release
      const vca = ctx.createGain();
      vca.gain.value = 0;

      // Chaînage: osc -> vca -> master -> destination
      osc.connect(vca);
      vca.connect(master);

      // Attack courte
      const t = now();
      const A = parseFloat(att.value);
      vca.gain.cancelScheduledValues(t);
      vca.gain.setValueAtTime(0, t);
      vca.gain.linearRampToValueAtTime(1, t + A);

      osc.start();
      return { osc, vca };
    }

    // === 4) Note ON/OFF à partir des touches ===
    function noteOn(key) {
      if (!ctx) initAudio();
      const freq = keyFreq[key.toLowerCase()];
      if (!freq) return;
      if (voices.has(key)) return; // déjà enfoncée

      const voice = createVoice(freq);
      voices.set(key, voice);
    }

    function noteOff(key) {
      const v = voices.get(key);
      if (!v) return;
      const t = now();
      const R = parseFloat(rel.value);

      // Release courte pour éviter le "click"
      v.vca.gain.cancelScheduledValues(t);
      v.vca.gain.setValueAtTime(v.vca.gain.value, t);
      v.vca.gain.linearRampToValueAtTime(0, t + R);

      // Arrêter l’osc après la fin du release
      setTimeout(() => { try { v.osc.stop(); } catch(e){} }, (R * 1000) + 20);
      voices.delete(key);
    }

    // === 5) Écoute clavier ===
    window.addEventListener('keydown', (e) => {
      if (e.repeat) return; // ignorer répétitions auto
      // S'assurer que le contexte est "running"
      if (ctx && ctx.state !== 'running') ctx.resume();
      noteOn(e.key);
    });

    window.addEventListener('keyup', (e) => noteOff(e.key));

    // === 6) Liens UI ===
    init.onclick = () => {
      initAudio();
      if (ctx.state !== 'running') ctx.resume();
    };

    panic.onclick = () => {
      // Couper toutes les voix
      for (const k of [...voices.keys()]) noteOff(k);
    };

    gain.oninput = e => master && (master.gain.value = parseFloat(e.target.value));
    wave.oninput = e => {};   // pris à la création de la voix
    detune.oninput = e => {}; // pris à la création de la voix
  </script>
</body>
</html>
